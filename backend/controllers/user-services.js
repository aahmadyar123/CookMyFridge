const userModel = require("../models/user");
const mongoose = require("mongoose");

const bcrypt = require("bcrypt");

async function register(email, password) {
  /*
  This function checks for valid login
  :param email: user email
  :param password: password for user
  :return: user model
  */
  try {
    //check if duplicate email
    duplicate = await userModel.findOne({ email: email });
    if (duplicate) {
      return undefined;
    }

    //create new user model and add to database
    if (password.length < 6)
      throw new Error(
        "Invalid password. Length must be at least 6 characters."
      );

    const hashedPword = await bcrypt.hash(password, 10);
    const userToAdd = new userModel({ email: email, password: hashedPword });
    const savedUser = await userToAdd.save();
    return savedUser;
  } catch (error) {
    console.log(error);
    return undefined;
  }
}

async function login(email, password) {
  /*
  This function checks for valid login
  :param email: user email
  :param password: password for user
  :return: user model
  */
  try {
    //get user
    const user = await userModel.findOne({ email: email });

    //invalid email (user does not exist)
    if (!user) throw new Error("Invalid email.");

    //compare entered password to one retreieved from DB
    const validPwd = await bcrypt.compare(password, user.password);
    if (validPwd) return user;
    else return undefined;
  } catch (error) {
    console.log(error);
    return undefined;
  }
}

async function getUsers(name) {
  // use mongoose to find all users that match this name
  let result = await userModel.find({ name: name });
  return result;
}

async function findUserById(id) {
  /*
  Finds user by id
  :param id: user database ID
  :return: user model with associated id
  */
  try {
    return await userModel.findById(id);
  } catch (error) {
    console.log(error);
    return undefined;
  }
}

async function addRecipe(userID, recipeID) {
  /*
  Adds recipe reference to user
  :param userID: id of user
  :param recipeID: recipe id
  :return: boolean if added successfully
  */
  try {
    const user = await findUserById(userID);

    if (user.recipes.includes(recipeID)) {
      return true;
    } else {
      user.recipes.push(recipeID);
      await user.save();
      return true;
    }
  } catch (error) {
    console.log(error);
    return false;
  }
}

async function removeRecipe(userID, recipeID) {
  /*
  Removes recipe reference from user
  :param userID: id of user
  :param recipeID: recipe id
  :return: boolean if removed successfully
  */
  try {
    // mongoRecipeId = mongoose.Types.ObjectId(recipeID);

    //remove recipe reference from user.recipes
    //const user = await userModel.find({ _id: userID });
    const user = await findUserById(userID);

    //check if recipe not favorited
    const idx = user.recipes.indexOf(recipeID);
    if (idx === -1) {
      return false;
    }
    //remove recipe if favorited
    else {
      user.recipes.splice(idx, 1);
      await user.save();
      return true;
    }
  } catch (error) {
    console.log(error);
    return false;
  }
}

async function getRecipes(userID) {
  /*
  This function populates a user's list of recipes
  :param: userID: id of user to get recipes from
  :return: array of recipes
  */
  try {
    //find user and populate recipes from doucment references
    let user = await findUserById(userID);
    let populatedUser = await userModel.populate(user, "recipes");
    return populatedUser.recipes;
  } catch (error) {
    console.log(error);
    return undefined;
  }
}

async function getIngredients(id) {
  /*
  Gets all ingredients associated with specified user
  :param id: id of user generated by MongoDB
  :return: list of ingredients associated with user
  */
  try {
    // populate without using utility functions
    const ingredients = await userModel.findById(id).select("ingredients");
    return ingredients;
  } catch (error) {
    console.log(error);
    return undefined;
  }
}

async function updateIngredients(id, userIngredients) {
  /*
  Updates user.ingredients field in database
  :param id: user id in database
  :param ingredients: updated list of ingredients for user
  :return: user model
  */
  try {
    //update ingredients field for user with specified id
    const result = await userModel.updateOne(
      { _id: id },
      { $set: { ingredients: userIngredients } }
    );

    ret = await userModel.findById(id);
    return ret;
  } catch (error) {
    console.log(error);
    return undefined;
  }
}

module.exports = {
  register,
  login,
  getUsers,
  findUserById,
  // deleteUser,
  addRecipe,
  getRecipes,
  getIngredients,
  updateIngredients,
  removeRecipe,
};

// ----------------- UNIMPLEMENTED -----------------
// async function deleteUser(login) {
//   /*
//   This function deletes a user from the database
//   Args:
//     login(JSON): login information to confirm deletion of account
//   Return:
//     boolean: true if deleted, false otherwise
//   */
//   try {
//     //get user
//     const user = await userModel.findOne({ email: login.email });

//     //invalid email (user does not exist)
//     if (!user) return false;

//     //compare entered password to one retreieved from DB
//     const validPwd = await bcrypt.compare(login.password, user.password);
//     if (validPwd) {
//       return (await userModel.findByIdAndDelete(user.id)) !== null;
//     } else return false;
//   } catch (error) {
//     console.log(error);
//     return false;
//   }
// }

// async function addFriend(user, friendId) {
//   /*
//   This function adds a friend to a user's list of friends
//   Args:
//     friendId: id of friend to add
//     user: user to add friend to
//   Return:
//     boolean: true if added, false otherwise
//   */
//   try {
//     user.friends.push(friendId);
//     await user.save();

//     return true;
//   } catch (error) {
//     console.log(error);
//     return false;
//   }
// }

// async function getFriends(user) {
//   /*
//   Populates and returns user friend list
//   :param user: user to get recipes from
//   :return: users populated friend list
//   */
//   try {
//     // populate without using utility functions
//     let populatedUser = await user.populate("friends");

//     // const recipes = await populateField(user, "recipes");
//     return populatedUser;
//   } catch (error) {
//     console.log(error);
//     return undefined;
//   }
// }
